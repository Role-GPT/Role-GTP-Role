/**
 * ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤
 * 
 * ë¬´ë£Œ ì²´í—˜(Craiyon)ê³¼ BYOK(ì‚¬ìš©ì API í‚¤) ê¸°ë°˜ ì´ë¯¸ì§€ ìƒì„±ì„ ì§€ì›
 * - Craiyon: í‚¤ë¦¬ìŠ¤ ë¬´ë£Œ ì²´í—˜ (ìŠ¤ì¼€ì¹˜ í’ˆì§ˆ)
 * - OpenAI DALL-E: ê³ í’ˆì§ˆ ì´ë¯¸ì§€ ìƒì„±
 * - Google Gemini: êµ¬ê¸€ ì´ë¯¸ì§€ ìƒì„± API
 * - Hugging Face: Stable Diffusion ë“±
 */

export interface ImageGenerationProvider {
  id: string;
  name: string;
  description: string;
  type: 'free' | 'byok';
  isAvailable: boolean;
  quality: 'sketch' | 'standard' | 'high';
  hasApiKey?: boolean;
  models?: Array<{
    id: string;
    name: string;
    description: string;
    defaultSize?: string;
  }>;
}

export interface ImageGenerationRequest {
  prompt: string;
  size?: '256x256' | '512x512' | '1024x1024' | '1792x1024' | '1024x1792';
  style?: 'natural' | 'vivid' | 'sketch' | 'artistic';
  provider?: string;
}

export interface ImageGenerationResult {
  imageUrl: string;
  provider: string;
  prompt: string;
  size: string;
  timestamp: Date;
  isBase64?: boolean;
}

// ì¼ì¼ ë¬´ë£Œ í•œë„ ê´€ë¦¬
const FREE_DAILY_LIMIT = 10;
const STORAGE_KEY = 'image_generation_usage';

interface DailyUsage {
  date: string;
  count: number;
}

/**
 * ì¼ì¼ ì‚¬ìš©ëŸ‰ í™•ì¸
 */
export function getDailyUsage(): number {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (!stored) return 0;
    
    const usage: DailyUsage = JSON.parse(stored);
    const today = new Date().toISOString().split('T')[0];
    
    if (usage.date !== today) {
      // ìƒˆë¡œìš´ ë‚ ì§œë©´ ë¦¬ì…‹
      localStorage.setItem(STORAGE_KEY, JSON.stringify({ date: today, count: 0 }));
      return 0;
    }
    
    return usage.count;
  } catch (error) {
    console.error('ì¼ì¼ ì‚¬ìš©ëŸ‰ í™•ì¸ ì‹¤íŒ¨:', error);
    return 0;
  }
}

/**
 * ì¼ì¼ ì‚¬ìš©ëŸ‰ ì¦ê°€
 */
export function incrementDailyUsage(): void {
  try {
    const today = new Date().toISOString().split('T')[0];
    const currentUsage = getDailyUsage();
    localStorage.setItem(STORAGE_KEY, JSON.stringify({ 
      date: today, 
      count: currentUsage + 1 
    }));
  } catch (error) {
    console.error('ì¼ì¼ ì‚¬ìš©ëŸ‰ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', error);
  }
}

/**
 * ë¬´ë£Œ í•œë„ í™•ì¸
 */
export function canUseFreeGeneration(): boolean {
  return getDailyUsage() < FREE_DAILY_LIMIT;
}

/**
 * Craiyon ë¬´ë£Œ ì´ë¯¸ì§€ ìƒì„± (ì„œë²„ë¦¬ìŠ¤ í•¨ìˆ˜ ì‚¬ìš©)
 */
export async function generateImageWithCraiyon(prompt: string): Promise<ImageGenerationResult> {
  if (!canUseFreeGeneration()) {
    throw new Error('ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë” ë‚˜ì€ ì´ë¯¸ì§€ í’ˆì§ˆê³¼ ë¬´ì œí•œ ìƒì„±ì„ ìœ„í•´ ê°œì¸ API í‚¤ë¥¼ ì—°ê²°í•´ì£¼ì„¸ìš”.');
  }

  try {
    console.log('ğŸ¨ Craiyon ì´ë¯¸ì§€ ìƒì„± ì‹œì‘:', prompt.substring(0, 50));
    
    const { projectId, publicAnonKey } = await import('../../../utils/supabase/info');
    
    const response = await fetch(`https://${projectId}.supabase.co/functions/v1/make-server-e3d1d00c/image/craiyon`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${publicAnonKey}`,
      },
      body: JSON.stringify({
        prompt: prompt
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error || `ì„œë²„ ì˜¤ë¥˜: ${response.status}`);
    }

    const data = await response.json();
    
    if (!data.success) {
      throw new Error(data.error || 'ì´ë¯¸ì§€ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    }

    incrementDailyUsage();

    return {
      imageUrl: data.imageUrl,
      provider: data.provider,
      prompt: data.prompt,
      size: data.size,
      timestamp: new Date(data.timestamp),
      isBase64: data.isBase64
    };
  } catch (error) {
    console.error('Craiyon ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨:', error);
    throw error;
  }
}

/**
 * OpenAI DALL-E ì´ë¯¸ì§€ ìƒì„± (ì„œë²„ë¦¬ìŠ¤ í•¨ìˆ˜ ì‚¬ìš©)
 */
export async function generateImageWithDALLE(
  prompt: string, 
  apiKey: string, 
  options: Partial<ImageGenerationRequest> = {}
): Promise<ImageGenerationResult> {
  try {
    console.log('ğŸ¨ DALL-E ì´ë¯¸ì§€ ìƒì„± ì‹œì‘:', prompt.substring(0, 50));
    
    const { projectId, publicAnonKey } = await import('../../../utils/supabase/info');
    
    const response = await fetch(`https://${projectId}.supabase.co/functions/v1/make-server-e3d1d00c/image/dalle`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${publicAnonKey}`,
      },
      body: JSON.stringify({
        prompt: prompt,
        apiKey: apiKey,
        size: options.size || '1024x1024',
        style: options.style || 'natural'
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error || `ì„œë²„ ì˜¤ë¥˜: ${response.status}`);
    }

    const data = await response.json();
    
    if (!data.success) {
      throw new Error(data.error || 'DALL-E ì´ë¯¸ì§€ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    }

    return {
      imageUrl: data.imageUrl,
      provider: data.provider,
      prompt: data.prompt,
      size: data.size,
      timestamp: new Date(data.timestamp)
    };
  } catch (error) {
    console.error('DALL-E ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨:', error);
    throw error;
  }
}

/**
 * Google ì´ë¯¸ì§€ ìƒì„± (ì„œë²„ë¦¬ìŠ¤ í•¨ìˆ˜ ì‚¬ìš©)
 */
export async function generateImageWithGoogle(
  prompt: string, 
  apiKey: string,
  options: Partial<ImageGenerationRequest> & { model?: string } = {}
): Promise<ImageGenerationResult> {
  try {
    console.log('ğŸ¨ Google ì´ë¯¸ì§€ ìƒì„± ì‹œì‘:', prompt.substring(0, 50));
    
    const { projectId, publicAnonKey } = await import('../../../utils/supabase/info');
    
    const response = await fetch(`https://${projectId}.supabase.co/functions/v1/make-server-e3d1d00c/image/google`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${publicAnonKey}`,
      },
      body: JSON.stringify({
        prompt: prompt,
        apiKey: apiKey,
        model: options.model || 'imagen-3.0-fast-generate-001',
        size: options.size || '1024x1024'
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error || `ì„œë²„ ì˜¤ë¥˜: ${response.status}`);
    }

    const data = await response.json();
    
    if (!data.success) {
      throw new Error(data.error || 'Google ì´ë¯¸ì§€ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    }

    return {
      imageUrl: data.imageUrl,
      provider: data.provider,
      prompt: data.prompt,
      size: data.size,
      timestamp: new Date(data.timestamp),
      isBase64: data.isBase64
    };
  } catch (error) {
    console.error('Google ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨:', error);
    throw error;
  }
}

/**
 * Hugging Face Stable Diffusion ì´ë¯¸ì§€ ìƒì„± (ì„œë²„ë¦¬ìŠ¤ í•¨ìˆ˜ ì‚¬ìš©)
 */
export async function generateImageWithHuggingFace(
  prompt: string, 
  apiKey: string,
  options: Partial<ImageGenerationRequest> = {}
): Promise<ImageGenerationResult> {
  try {
    console.log('ğŸ¨ Hugging Face ì´ë¯¸ì§€ ìƒì„± ì‹œì‘:', prompt.substring(0, 50));
    
    const { projectId, publicAnonKey } = await import('../../../utils/supabase/info');
    
    const response = await fetch(`https://${projectId}.supabase.co/functions/v1/make-server-e3d1d00c/image/huggingface`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${publicAnonKey}`,
      },
      body: JSON.stringify({
        prompt: prompt,
        apiKey: apiKey
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error || `ì„œë²„ ì˜¤ë¥˜: ${response.status}`);
    }

    const data = await response.json();
    
    if (!data.success) {
      throw new Error(data.error || 'Hugging Face ì´ë¯¸ì§€ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    }

    return {
      imageUrl: data.imageUrl,
      provider: data.provider,
      prompt: data.prompt,
      size: data.size,
      timestamp: new Date(data.timestamp),
      isBase64: data.isBase64
    };
  } catch (error) {
    console.error('Hugging Face ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨:', error);
    throw error;
  }
}

/**
 * ë©”ì¸ ì´ë¯¸ì§€ ìƒì„± í•¨ìˆ˜
 */
export async function generateImage(
  request: ImageGenerationRequest,
  userSettings: any
): Promise<ImageGenerationResult> {
  const { prompt, provider } = request;
  
  // Provider ìš°ì„ ìˆœìœ„ ê²°ì •
  let selectedProvider = provider;
  
  if (!selectedProvider) {
    // ì‚¬ìš©ìê°€ ì„¤ì •í•œ ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì„ íƒ
    const imageSettings = userSettings.imageGeneration || {};
    const availableProviders = getAvailableProviders(userSettings);
    
    selectedProvider = availableProviders.find(p => p.isAvailable)?.id || 'craiyon';
  }

  console.log('ğŸ¯ ì´ë¯¸ì§€ ìƒì„± ìš”ì²­:', {
    provider: selectedProvider,
    prompt: prompt.substring(0, 50) + '...',
    size: request.size
  });

  switch (selectedProvider) {
    case 'craiyon':
      return await generateImageWithCraiyon(prompt);
    
    case 'dalle':
      const dalleKey = userSettings.apiKeys?.openai;
      if (!dalleKey) {
        throw new Error('OpenAI API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
      }
      return await generateImageWithDALLE(prompt, dalleKey, request);
    
    case 'google':
    case 'gemini':
    case 'imagen-2':
    case 'imagen-3':
    case 'imagen-4':
    case 'gemini-2.5-flash-image':
      const googleKey = userSettings.apiKeys?.google_gemini;
      if (!googleKey) {
        throw new Error('Google API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
      }
      
      // ëª¨ë¸ ë§¤í•‘
      let modelName = 'imagen-3.0-fast-generate-001'; // ê¸°ë³¸ê°’
      if (selectedProvider === 'imagen-2') modelName = 'imagen-2.0-generate-001';
      if (selectedProvider === 'imagen-3') modelName = 'imagen-3.0-generate-001';
      if (selectedProvider === 'imagen-4') modelName = 'imagen-4.0-generate-001';
      if (selectedProvider === 'gemini-2.5-flash-image') modelName = 'gemini-2.5-flash-image-001';
      
      return await generateImageWithGoogle(prompt, googleKey, { ...request, model: modelName });
    
    case 'huggingface':
      const hfKey = userSettings.apiKeys?.huggingface;
      if (!hfKey) {
        throw new Error('Hugging Face API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
      }
      return await generateImageWithHuggingFace(prompt, hfKey, request);
    
    default:
      // ê¸°ë³¸ê°’ìœ¼ë¡œ ë¬´ë£Œ Craiyon ì‚¬ìš©
      return await generateImageWithCraiyon(prompt);
  }
}

/**
 * ì‚¬ìš© ê°€ëŠ¥í•œ Provider ëª©ë¡ ì¡°íšŒ
 */
export function getAvailableProviders(userSettings: any): ImageGenerationProvider[] {
  const apiKeys = userSettings.apiKeys || {};
  const hasGoogleKey = !!apiKeys.google_gemini;
  
  const providers: ImageGenerationProvider[] = [
    {
      id: 'craiyon',
      name: 'Craiyon',
      description: 'ë¬´ë£Œ ì²´í—˜',
      type: 'free',
      isAvailable: canUseFreeGeneration(),
      quality: 'sketch'
    },
    {
      id: 'dalle',
      name: 'DALL-E 3',
      description: 'OpenAI ê³ í’ˆì§ˆ',
      type: 'byok',
      isAvailable: !!apiKeys.openai,
      quality: 'high',
      hasApiKey: !!apiKeys.openai
    }
  ];

  // Google ëª¨ë¸ë“¤ (ë™ì¼í•œ í‚¤ë¡œ ë‹¤ì¤‘ ëª¨ë¸ ì§€ì›)
  if (hasGoogleKey) {
    providers.push(
      {
        id: 'imagen-3',
        name: 'Imagen 3.0',
        description: 'Google ìµœì‹ ',
        type: 'byok',
        isAvailable: true,
        quality: 'high',
        hasApiKey: true
      },
      {
        id: 'imagen-2',
        name: 'Imagen 2.0',
        description: 'Google í‘œì¤€',
        type: 'byok',
        isAvailable: true,
        quality: 'high',
        hasApiKey: true
      },
      {
        id: 'gemini-2.5-flash-image',
        name: 'Gemini Flash Image',
        description: 'Google ë¹ ë¥¸ìƒì„±',
        type: 'byok',
        isAvailable: true,
        quality: 'standard',
        hasApiKey: true
      }
    );
  } else {
    // API í‚¤ê°€ ì—†ì„ ë•Œë„ í‘œì‹œí•˜ë˜ ë¹„í™œì„±í™”
    providers.push(
      {
        id: 'google-group',
        name: 'Google ëª¨ë¸ë“¤',
        description: 'API í‚¤ í•„ìš”',
        type: 'byok',
        isAvailable: false,
        quality: 'high',
        hasApiKey: false,
        models: [
          { id: 'imagen-3', name: 'Imagen 3.0', description: 'ìµœì‹  ëª¨ë¸' },
          { id: 'imagen-2', name: 'Imagen 2.0', description: 'í‘œì¤€ ëª¨ë¸' },
          { id: 'gemini-2.5-flash-image', name: 'Gemini Flash Image', description: 'ë¹ ë¥¸ ìƒì„±' }
        ]
      }
    );
  }

  providers.push(
    {
      id: 'huggingface',
      name: 'Stable Diffusion',
      description: 'HuggingFace ì˜¤í”ˆì†ŒìŠ¤',
      type: 'byok',
      isAvailable: !!apiKeys.huggingface,
      quality: 'standard',
      hasApiKey: !!apiKeys.huggingface
    }
  );

  // ì‚¬ìš©ì ì •ì˜ Providerë“¤ ì¶”ê°€
  const customProviders = getCustomImageProviders(userSettings);
  providers.push(...customProviders);

  return providers;
}

/**
 * ì‚¬ìš©ì ì •ì˜ ì´ë¯¸ì§€ Provider ì¡°íšŒ
 */
export function getCustomImageProviders(userSettings: any): ImageGenerationProvider[] {
  const customProviders = userSettings.customImageProviders || [];
  
  return customProviders.map((provider: any) => ({
    id: provider.id,
    name: provider.name,
    description: provider.description || 'ì‚¬ìš©ì ì •ì˜',
    type: 'byok' as const,
    isAvailable: !!provider.apiKey,
    quality: provider.quality || 'standard' as const,
    hasApiKey: !!provider.apiKey
  }));
}

/**
 * ì´ë¯¸ì§€ ìƒì„± íˆìŠ¤í† ë¦¬ ê´€ë¦¬
 */
const HISTORY_STORAGE_KEY = 'image_generation_history';
const MAX_HISTORY_ITEMS = 50;

export interface ImageHistoryItem extends ImageGenerationResult {
  id: string;
}

export function getImageHistory(): ImageHistoryItem[] {
  try {
    const stored = localStorage.getItem(HISTORY_STORAGE_KEY);
    return stored ? JSON.parse(stored) : [];
  } catch (error) {
    console.error('ì´ë¯¸ì§€ íˆìŠ¤í† ë¦¬ ë¡œë“œ ì‹¤íŒ¨:', error);
    return [];
  }
}

export function addToImageHistory(result: ImageGenerationResult): void {
  try {
    const history = getImageHistory();
    const newItem: ImageHistoryItem = {
      ...result,
      id: `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    };
    
    history.unshift(newItem);
    
    // ìµœëŒ€ ê°œìˆ˜ ì œí•œ
    if (history.length > MAX_HISTORY_ITEMS) {
      history.splice(MAX_HISTORY_ITEMS);
    }
    
    localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
  } catch (error) {
    console.error('ì´ë¯¸ì§€ íˆìŠ¤í† ë¦¬ ì €ì¥ ì‹¤íŒ¨:', error);
  }
}

export function clearImageHistory(): void {
  localStorage.removeItem(HISTORY_STORAGE_KEY);
}