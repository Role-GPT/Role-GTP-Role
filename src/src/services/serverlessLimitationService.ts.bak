/**
 * ğŸ” ì„œë²„ë¦¬ìŠ¤ ëª¨ë“œë³„ ì œí•œì‚¬í•­ ì„œë¹„ìŠ¤
 * 
 * ëª¨ë“  ì œí•œì‚¬í•­ì„ ì„œë²„ì—ì„œ ê´€ë¦¬í•˜ì—¬ ë³´ì•ˆì„ ê°•í™”í•©ë‹ˆë‹¤.
 * í´ë¼ì´ì–¸íŠ¸ì—ì„œëŠ” ë‹¨ìˆœíˆ ì„œë²„ APIë¥¼ í˜¸ì¶œí•˜ì—¬ ì œí•œì‚¬í•­ì„ í™•ì¸í•©ë‹ˆë‹¤.
 */

import { projectId, publicAnonKey } from '../../../../utils/supabase/info';

const API_BASE_URL = `https://${projectId}.supabase.co/functions/v1/make-server-e3d1d00c`;

/**
 * ì„œë²„ë¦¬ìŠ¤ ì œí•œì‚¬í•­ ì„œë¹„ìŠ¤ í´ë˜ìŠ¤
 */
export class ServerlessLimitationService {
  private static headers = {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${publicAnonKey}`
  };

  /**
   * ğŸ” ëª¨ë“œë³„ ì œí•œì‚¬í•­ ì¡°íšŒ (ì„œë²„ì—ì„œ)
   * 
   * @param userMode - ì‚¬ìš©ì ëª¨ë“œ
   * @returns Promise<any>
   */
  static async getModeLimitations(userMode: 'standard' | 'advanced' | 'expert'): Promise<any> {
    try {
      console.log('ğŸ” ì„œë²„ì—ì„œ ëª¨ë“œë³„ ì œí•œì‚¬í•­ ì¡°íšŒ:', { userMode });
      
      const response = await fetch(`${API_BASE_URL}/mode/limitations/${userMode}`, {
        method: 'GET',
        headers: this.headers
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'ëª¨ë“œë³„ ì œí•œì‚¬í•­ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
      }

      const data = await response.json();
      console.log('âœ… ì„œë²„ì—ì„œ ëª¨ë“œë³„ ì œí•œì‚¬í•­ ì¡°íšŒ ì™„ë£Œ');
      
      return data;
    } catch (error) {
      console.error('ëª¨ë“œë³„ ì œí•œì‚¬í•­ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜:', error);
      throw error;
    }
  }

  /**
   * ğŸ” ì‹¤ì‹œê°„ ì•¡ì…˜ ì œí•œ ê²€ì¦ (ì„œë²„ì—ì„œ)
   * 
   * @param userId - ì‚¬ìš©ì ID
   * @param userMode - ì‚¬ìš©ì ëª¨ë“œ
   * @param action - ì‹¤í–‰í•˜ë ¤ëŠ” ì•¡ì…˜
   * @param currentUsage - í˜„ì¬ ì‚¬ìš©ëŸ‰
   * @returns Promise<any>
   */
  static async validateAction(
    userId: string,
    userMode: 'standard' | 'advanced' | 'expert',
    action: string,
    currentUsage: any
  ): Promise<any> {
    try {
      console.log('ğŸ” ì„œë²„ì—ì„œ ì•¡ì…˜ ì œí•œ ê²€ì¦:', { userId, userMode, action });
      
      // Timeout ì„¤ì • (10ì´ˆ)
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000);
      
      const response = await fetch(`${API_BASE_URL}/mode/validate-action`, {
        method: 'POST',
        headers: this.headers,
        signal: controller.signal,
        body: JSON.stringify({
          userId,
          userMode,
          action,
          currentUsage
        })
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        let errorData;
        try {
          errorData = await response.json();
          console.error('ğŸš¨ ì„œë²„ë¦¬ìŠ¤ ì•¡ì…˜ ê²€ì¦ ì‹¤íŒ¨ ìƒì„¸:', {
            status: response.status,
            statusText: response.statusText,
            errorData,
            requestData: { userId, userMode, action, currentUsage }
          });
        } catch (parseError) {
          console.error('ğŸš¨ ì„œë²„ë¦¬ìŠ¤ ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨:', parseError);
          errorData = { error: `HTTP ${response.status} ${response.statusText}` };
        }
        throw new Error(errorData.error || 'ì•¡ì…˜ ì œí•œ ê²€ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
      }

      const data = await response.json();
      console.log('âœ… ì„œë²„ì—ì„œ ì•¡ì…˜ ì œí•œ ê²€ì¦ ì™„ë£Œ:', data.allowed ? 'í—ˆìš©' : 'ì œí•œë¨');
      
      return data;
    } catch (error) {
      if (error.name === 'AbortError') {
        console.error('ì•¡ì…˜ ì œí•œ ê²€ì¦ íƒ€ì„ì•„ì›ƒ');
        throw new Error('ì„œë²„ ì‘ë‹µ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤');
      }
      
      console.error('ì•¡ì…˜ ì œí•œ ê²€ì¦ ì¤‘ ì˜¤ë¥˜:', error);
      throw error;
    }
  }

  /**
   * ğŸ“Š ì‚¬ìš©ëŸ‰ ì¶”ì  (ì„œë²„ì—ì„œ)
   * 
   * @param userId - ì‚¬ìš©ì ID
   * @param userMode - ì‚¬ìš©ì ëª¨ë“œ
   * @param action - ì‹¤í–‰ëœ ì•¡ì…˜
   * @param metadata - ì¶”ê°€ ë©”íƒ€ë°ì´í„°
   * @returns Promise<any>
   */
  static async trackUsage(
    userId: string,
    userMode: 'standard' | 'advanced' | 'expert',
    action: string,
    metadata?: any
  ): Promise<any> {
    try {
      console.log('ğŸ“Š ì„œë²„ì—ì„œ ì‚¬ìš©ëŸ‰ ì¶”ì :', { userId, userMode, action });
      
      const response = await fetch(`${API_BASE_URL}/mode/track-usage`, {
        method: 'POST',
        headers: this.headers,
        body: JSON.stringify({
          userId,
          userMode,
          action,
          metadata
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'ì‚¬ìš©ëŸ‰ ì¶”ì ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
      }

      const data = await response.json();
      console.log('âœ… ì„œë²„ì—ì„œ ì‚¬ìš©ëŸ‰ ì¶”ì  ì™„ë£Œ');
      
      return data;
    } catch (error) {
      console.error('ì‚¬ìš©ëŸ‰ ì¶”ì  ì¤‘ ì˜¤ë¥˜:', error);
      throw error;
    }
  }

  /**
   * ğŸ“ˆ í˜„ì¬ ì‚¬ìš©ëŸ‰ ì¡°íšŒ (ì„œë²„ì—ì„œ)
   * 
   * @param userId - ì‚¬ìš©ì ID
   * @returns Promise<any>
   */
  static async getCurrentUsage(userId: string): Promise<any> {
    try {
      console.log('ğŸ“ˆ ì„œë²„ì—ì„œ í˜„ì¬ ì‚¬ìš©ëŸ‰ ì¡°íšŒ:', { userId });
      
      // Timeout ì„¤ì • (10ì´ˆ)
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000);
      
      const response = await fetch(`${API_BASE_URL}/mode/usage/${userId}`, {
        method: 'GET',
        headers: this.headers,
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        let errorData;
        try {
          errorData = await response.json();
          console.error('ğŸš¨ ì„œë²„ë¦¬ìŠ¤ ì‚¬ìš©ëŸ‰ ì¡°íšŒ ì‹¤íŒ¨ ìƒì„¸:', {
            status: response.status,
            statusText: response.statusText,
            errorData,
            userId
          });
        } catch (parseError) {
          console.error('ğŸš¨ ì„œë²„ë¦¬ìŠ¤ ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨:', parseError);
          errorData = { error: `HTTP ${response.status} ${response.statusText}` };
        }
        throw new Error(errorData.error || 'í˜„ì¬ ì‚¬ìš©ëŸ‰ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
      }

      const data = await response.json();
      console.log('âœ… ì„œë²„ì—ì„œ í˜„ì¬ ì‚¬ìš©ëŸ‰ ì¡°íšŒ ì™„ë£Œ');
      
      return data;
    } catch (error) {
      if (error.name === 'AbortError') {
        console.error('í˜„ì¬ ì‚¬ìš©ëŸ‰ ì¡°íšŒ íƒ€ì„ì•„ì›ƒ');
        throw new Error('ì„œë²„ ì‘ë‹µ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤');
      }
      
      console.error('í˜„ì¬ ì‚¬ìš©ëŸ‰ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜:', error);
      throw error;
    }
  }

  /**
   * ğŸš« í´ë¼ì´ì–¸íŠ¸ í´ë°± ì œí•œì‚¬í•­ (ìµœì†Œí•œì˜ ê¸°ë³¸ê°’)
   * 
   * ì„œë²„ ì—°ê²° ì‹¤íŒ¨ì‹œ ì‚¬ìš©í•˜ëŠ” ê¸°ë³¸ ì œí•œì‚¬í•­
   * ë³´ì•ˆìƒ ê°€ì¥ ì œí•œì ì¸ standard ëª¨ë“œ ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •
   */
  static getFallbackLimitations() {
    return {
      userMode: 'standard',
      limitations: {
        maxProjects: 2,
        maxConversations: 10,
        maxCustomRoles: 6,
        canExportChats: false,
        canImportChats: false,
        canDuplicateChats: false,
        canCreateCustomRoles: false,
        canAccessAdvancedFeatures: false,
        showAdvancedSettings: false,
        showExpertFeatures: false,
        maxApiCallsPerDay: 50
      },
      features: {
        timelineReminder: false,
        summaryControl: false,
        summaryToggle: false,
        formatSelection: false,
        advancedSettings: false,
        expertFeatures: false,
        customKeywords: false,
        advancedModels: false
      },
      message: 'ì„œë²„ ì—°ê²° ì‹¤íŒ¨ë¡œ ê¸°ë³¸ ì œí•œì‚¬í•­ì„ ì ìš©í–ˆìŠµë‹ˆë‹¤.'
    };
  }
}

/**
 * í¸ì˜ í•¨ìˆ˜ë“¤
 */

// ëª¨ë“œë³„ ì œí•œì‚¬í•­ ì¡°íšŒ (ê°„í¸ í•¨ìˆ˜)
export const getModeLimitations = (userMode: 'standard' | 'advanced' | 'expert') => {
  return ServerlessLimitationService.getModeLimitations(userMode);
};

// ì•¡ì…˜ ì œí•œ ê²€ì¦ (ê°„í¸ í•¨ìˆ˜)
export const validateAction = (
  userId: string,
  userMode: 'standard' | 'advanced' | 'expert',
  action: string,
  currentUsage: any
) => {
  return ServerlessLimitationService.validateAction(userId, userMode, action, currentUsage);
};

// ì‚¬ìš©ëŸ‰ ì¶”ì  (ê°„í¸ í•¨ìˆ˜)
export const trackUsage = (
  userId: string,
  userMode: 'standard' | 'advanced' | 'expert',
  action: string,
  metadata?: any
) => {
  return ServerlessLimitationService.trackUsage(userId, userMode, action, metadata);
};

// í˜„ì¬ ì‚¬ìš©ëŸ‰ ì¡°íšŒ (ê°„í¸ í•¨ìˆ˜)
export const getCurrentUsage = (userId: string) => {
  return ServerlessLimitationService.getCurrentUsage(userId);
};

/**
 * ì•¡ì…˜ íƒ€ì… ì •ì˜
 */
export type LimitationAction = 
  | 'create_project'
  | 'create_conversation'
  | 'create_custom_role'
  | 'import_chats'
  | 'duplicate_chats'
  | 'advanced_timeline_settings'
  | 'api_call'
  | 'export_chat';

/**
 * ì‚¬ìš©ëŸ‰ íƒ€ì… ì •ì˜
 */
export interface CurrentUsage {
  projects: number;
  conversations: number;
  customRoles: number;
  apiCallsToday: number;
  exportedChats: number;
}

/**
 * ì œí•œì‚¬í•­ ì‘ë‹µ íƒ€ì…
 */
export interface LimitationResponse {
  success: boolean;
  userMode: string;
  limitations: any;
  features: any;
  timestamp?: string;
}

/**
 * ì•¡ì…˜ ê²€ì¦ ì‘ë‹µ íƒ€ì…
 */
export interface ActionValidationResponse {
  success: boolean;
  allowed: boolean;
  reason: string;
  upgradeRequired: boolean;
  currentLimits: any;
  currentUsage: CurrentUsage;
}

export default ServerlessLimitationService;